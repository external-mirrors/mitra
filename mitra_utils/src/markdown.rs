use std::borrow::Cow;

use comrak::{
    format_commonmark,
    format_html,
    nodes::{Ast, AstNode, ListType, NodeValue},
    parse_document,
    Arena,
    ExtensionOptions,
    Options,
    ParseOptions,
    RenderOptions,
};
use regex::{Captures, Regex};

use crate::html::URI_SCHEMES;

#[derive(thiserror::Error, Debug)]
pub enum MarkdownError {
    #[error(transparent)]
    IoError(#[from] std::io::Error),

    #[error(transparent)]
    Utf8Error(#[from] std::string::FromUtf8Error),
}

fn build_comrak_options<'cb>() -> Options<'cb> {
    Options {
        extension: ExtensionOptions::builder()
            .autolink(true)
            .underline(true)
            .strikethrough(true)
            .greentext(true)
            .build(),
        parse: ParseOptions::builder()
            .relaxed_autolinks(true)
            .build(),
        render: RenderOptions::builder()
            .hardbreaks(true)
            .escape(true)
            .ol_width(4)
            .experimental_minimize_commonmark(true)
            .build(),
    }
}

/// Prevents underscores in mentions from being parsed as emphasis markers
fn protect_mentions(text: &str) -> Cow<'_, str> {
    let mention_re = Regex::new(r#"(?m)@([\w]+)@"#)
        .expect("regexp should be valid");
    mention_re.replace_all(text, |caps: &Captures| -> String {
        let escaped = caps[1].replace('_', r#"\_"#);
        format!("@{}@", escaped)
    })
}

fn iter_nodes<'a, F>(
    node: &'a AstNode<'a>,
    func: &F,
) -> Result<(), MarkdownError>
    where F: Fn(&'a AstNode<'a>) -> Result<(), MarkdownError>
{
    func(node)?;
    for child in node.children() {
        iter_nodes(child, func)?;
    };
    Ok(())
}

fn node_to_markdown<'a>(
    node: &'a AstNode<'a>,
    options: &Options,
) -> Result<String, MarkdownError> {
    let mut output = vec![];
    format_commonmark(node, options, &mut output)?;
    let markdown = String::from_utf8(output)?
        .trim_end_matches('\n')
        .to_string();
    Ok(markdown)
}

fn node_to_source<'a>(
    node: &'a AstNode<'a>,
    source: &str,
) -> Option<String> {
    let sourcepos = node.data.borrow().sourcepos;
    if sourcepos.start.line != sourcepos.end.line {
        // Ignore multi line elements
        return None;
    };
    let start_line = sourcepos.start.line.checked_sub(1)?;
    let line = source.lines().nth(start_line)?;
    let start_column = sourcepos.start.column.checked_sub(1)?;
    let length = sourcepos.end.column.checked_sub(sourcepos.start.column)?;
    let text = line.chars()
        .skip(start_column)
        .take(length + 1)
        .collect();
    Some(text)
}

fn replace_node_value(node: &AstNode, value: NodeValue) -> () {
    let mut borrowed_node = node.data.borrow_mut();
    *borrowed_node = Ast::new(value, borrowed_node.sourcepos.start);
}

fn replace_with_markdown<'a>(
    node: &'a AstNode<'a>,
    options: &Options,
) -> Result<(), MarkdownError> {
    // Replace node with text node containing markdown
    let markdown = node_to_markdown(node, options)?;
    for child in node.children() {
        child.detach();
    };
    let text = NodeValue::Text(markdown);
    replace_node_value(node, text);
    Ok(())
}

fn unlink<'a>(node: &'a AstNode<'a>) -> () {
    let mut link_text = String::new();
    for child in node.children() {
        child.detach();
        let child_value = &child.data.borrow().value;
        if let NodeValue::Text(child_text) = child_value {
            link_text.push_str(child_text);
        };
    };
    let text = NodeValue::Text(link_text);
    replace_node_value(node, text);
}

fn is_microsyntax<'a>(
    node: &'a AstNode<'a>,
) -> Result<bool, MarkdownError> {
    if let Some(prev) = node.previous_sibling() {
        if let NodeValue::Text(ref prev_text) = prev.data.borrow().value {
            // Remove autolink if mention or object link syntax is found
            if prev_text.ends_with('@') || prev_text.ends_with("[[") {
                return Ok(true);
            };
        };
    };
    Ok(false)
}

fn is_uri_scheme_allowed(uri: &str) -> bool {
    URI_SCHEMES.iter().any(|scheme| uri.starts_with(scheme))
}

fn is_email_autolink<'a>(
    node: &'a AstNode<'a>,
    text: &str,
) -> bool {
    let NodeValue::Link(ref link) = node.data.borrow().value else {
        return false;
    };
    if !link.url.starts_with("mailto:") {
        return false;
    };
    let Some(source) = node_to_source(node, text) else {
        return false;
    };
    link.url == format!("mailto:{source}")
}

fn document_to_html<'a>(
    document: &'a AstNode<'a>,
    options: &Options,
) -> Result<String, MarkdownError> {
    let mut output = vec![];
    format_html(document, options, &mut output)?;
    let html = String::from_utf8(output)?;
    Ok(html)
}

/// Removes extra soft breaks from a HTML document generated by comrak
fn fix_linebreaks(html: &str) -> String {
    html
        // Fix hardbreaks
        .replace("<br />\n", "<br>")
        // Remove extra soft breaks
        .replace(">\n<", "><")
        .trim_end_matches('\n')
        .to_string()
}

/// Markdown Lite
///
/// Supported features:
/// - headings (level 1 only)
/// - blockquotes
/// - bold and italic
/// - links and autolinks
/// - inline code and code blocks
/// - strikethrough
///
/// The output should be displayed correctly on all popular platforms:
/// https://funfedi.dev/support_tables/generated/html_tags/
pub fn markdown_lite_to_html(text: &str) -> Result<String, MarkdownError> {
    let options = build_comrak_options();
    let arena = Arena::new();

    let text = protect_mentions(text);
    let root = parse_document(
        &arena,
        &text,
        &options,
    );

    // Re-render headings, HRs and lists
    // Replace images with links
    // TODO: disable parser rules https://github.com/kivikakk/comrak/issues/244
    iter_nodes(root, &|node| {
        let node_value = node.data.borrow().value.clone();
        match node_value {
            // Level 1 headings are allowed.
            // Consecutive headings poorly degrade on Pleroma:
            // https://git.pleroma.social/pleroma/pleroma/-/issues/2413
            NodeValue::Heading(heading) if heading.level == 1 => (),
            // Blocks
            NodeValue::Heading(_) | NodeValue::ThematicBreak => {
                // Replace children with paragraph containing markdown
                let markdown = node_to_markdown(node, &options)?;
                for child in node.children() {
                    child.detach();
                };
                let text = NodeValue::Text(markdown);
                let text_node = arena.alloc(AstNode::from(text));
                node.append(text_node);
                replace_node_value(node, NodeValue::Paragraph);
            },
            NodeValue::Image(_) => replace_with_markdown(node, &options)?,
            NodeValue::List(_) => {
                // Replace list and list item nodes
                // while preserving their contents
                let mut replacements: Vec<&AstNode> = vec![];
                for list_item in node.children() {
                    let mut contents = vec![];
                    for paragraph in list_item.children() {
                        for content_node in paragraph.children() {
                            contents.push(content_node);
                        };
                        paragraph.detach();
                    };
                    let mut list_prefix_markdown =
                        node_to_markdown(list_item, &options)?;
                    if let NodeValue::Item(item) = list_item.data.borrow().value {
                        if item.list_type == ListType::Ordered {
                            // Preserve numbering in ordered lists
                            let item_index_str = item.start.to_string();
                            list_prefix_markdown =
                                list_prefix_markdown.replace('1', &item_index_str);
                        };
                    };
                    if !replacements.is_empty() {
                        // Insert line break before next list item
                        let linebreak = NodeValue::LineBreak;
                        let linebreak_node =
                            arena.alloc(AstNode::from(linebreak));
                        replacements.push(linebreak_node);
                    };
                    let list_prefix = NodeValue::Text(list_prefix_markdown);
                    let list_prefix_node =
                        arena.alloc(AstNode::from(list_prefix));
                    replacements.push(list_prefix_node);
                    for content_node in contents {
                        replacements.push(content_node);
                    };
                    list_item.detach();
                };
                for child_node in replacements {
                    node.append(child_node);
                };
                replace_node_value(node, NodeValue::Paragraph);
            },
            NodeValue::Link(link) => {
                if
                    is_microsyntax(node)?
                    || !is_uri_scheme_allowed(&link.url)
                    || is_email_autolink(node, &text)
                {
                    unlink(node);
                };
            },
            _ => (),
        };
        Ok(())
    })?;

    let html = document_to_html(root, &options)?;
    let html = fix_linebreaks(&html);
    Ok(html)
}

/// Markdown Basic
/// Supported features: links, linebreaks
pub fn markdown_basic_to_html(text: &str) -> Result<String, MarkdownError> {
    let options = {
        let mut options = build_comrak_options();
        options.extension.underline = false;
        options.extension.strikethrough = false;
        options
    };
    let arena = Arena::new();
    let root = parse_document(
        &arena,
        text,
        &options,
    );

    iter_nodes(root, &|node| {
        let node_value = node.data.borrow().value.clone();
        match node_value {
            NodeValue::Document |
            NodeValue::Text(_) |
            NodeValue::SoftBreak |
            NodeValue::LineBreak
                => (),
            NodeValue::Link(link) => {
                if
                    is_microsyntax(node)?
                    || !is_uri_scheme_allowed(&link.url)
                    || is_email_autolink(node, text)
                {
                    unlink(node);
                };
            },
            NodeValue::Paragraph => {
                if node.next_sibling().is_some() {
                    // If this is not the last paragraph,
                    // insert a line break, otherwise line break will not
                    // be preserved during HTML cleaning.
                    if let Some(last_child) = node.last_child() {
                        let last_child_value = &last_child.data.borrow().value;
                        if !matches!(last_child_value, NodeValue::LineBreak) {
                            let line_break = NodeValue::LineBreak;
                            let line_break_node =
                                arena.alloc(AstNode::from(line_break));
                            node.append(line_break_node);
                        };
                    };
                };
            },
            _ => replace_with_markdown(node, &options)?,
        };
        Ok(())
    })?;

    let html = document_to_html(root, &options)?;
    let html = fix_linebreaks(&html);
    Ok(html)
}

/// Full markdown
pub fn markdown_to_html(text: &str) -> String {
    let options = build_comrak_options();
    comrak::markdown_to_html(text, &options)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_markdown_lite_to_html() {
        let text = "# heading\n\ntest **bold** test *italic* test ~~strike~~ with `code`, <span>html</span> and https://example.com\nnew line\n\ntwo new lines and a list:\n- item 1\n- item 2\n\n>greentext\n\n---\n\nimage: ![logo](logo.png)\n\ncode block:\n```\nlet test\ntest = 1\n```";
        let html = markdown_lite_to_html(text).unwrap();
        let expected_html = concat!(
            r#"<h1>heading</h1><p>test <strong>bold</strong> test <em>italic</em> test <del>strike</del> with <code>code</code>, &lt;span&gt;html&lt;/span&gt;"#,
            r#" and <a href="https://example.com">https://example.com</a>"#,
            r#"<br>new line</p><p>two new lines and a list:</p><p>- item 1<br>- item 2</p><p>&gt;greentext</p><p>-----</p><p>image: ![logo](logo.png)</p><p>code block:</p>"#,
            "<pre><code>let test\ntest = 1\n</code></pre>",
        );
        assert_eq!(html, expected_html);
    }

    #[test]
    fn test_markdown_lite_to_html_headings() {
        // Level 2: depends on experimental_minimize_commonmark flag
        let text = "# heading1\n\n## heading2!\n\ntext";
        let html = markdown_lite_to_html(text).unwrap();
        let expected_html = r#"<h1>heading1</h1><p>## heading2!</p><p>text</p>"#;
        assert_eq!(html, expected_html);
    }

    #[test]
    fn test_markdown_lite_to_html_with_blockquote() {
        let text = "> one\n> two\n>three\n";
        let html = markdown_lite_to_html(text).unwrap();
        let expected_html = r#"<blockquote><p>one<br>two</p></blockquote><p>&gt;three</p>"#;
        assert_eq!(html, expected_html);
    }

    #[test]
    fn test_markdown_lite_to_html_underline() {
        let text = "__underline__";
        let html = markdown_lite_to_html(text).unwrap();
        let expected_html = r#"<p><u>underline</u></p>"#;
        assert_eq!(html, expected_html);
    }

    #[test]
    fn test_markdown_lite_to_html_ordered_list() {
        let text = "1. item 1\n2. item 2\n";
        let html = markdown_lite_to_html(text).unwrap();
        let expected_html = r#"<p>1.  item 1<br>2.  item 2</p>"#;
        assert_eq!(html, expected_html);
    }

    #[test]
    fn test_markdown_lite_to_html_with_greentext() {
        let text = ">one\n>two\n>three\n\ntest";
        let html = markdown_lite_to_html(text).unwrap();
        let expected_html = r#"<p>&gt;one<br>&gt;two<br>&gt;three</p><p>test</p>"#;
        assert_eq!(html, expected_html);
    }

    #[test]
    fn test_markdown_lite_to_html_lt_gt_in_codeblocks() {
        let text = "```\n<\n> test\n```";
        let html = markdown_lite_to_html(text).unwrap();
        assert_eq!(
            html,
            "<pre><code>&lt;\n&gt; test\n</code></pre>",
        );
    }

    #[test]
    fn test_markdown_lite_to_html_strikethrough() {
        let text = "test ~~strikethrough~~\n~test~ end.";
        let html = markdown_lite_to_html(text).unwrap();
        let expected_html = r#"<p>test <del>strikethrough</del><br><del>test</del> end.</p>"#;
        assert_eq!(html, expected_html);
    }

    #[test]
    fn test_markdown_lite_to_html_mention() {
        let text = "@user@example.org test";
        let html = markdown_lite_to_html(text).unwrap();
        assert_eq!(html, format!("<p>{}</p>", text));
    }

    #[test]
    fn test_markdown_lite_to_html_mention_with_underscores() {
        let text = r#"@_user_@example.org test"#;
        let html = markdown_lite_to_html(text).unwrap();
        assert_eq!(html, "<p>@_user_@example.org test</p>");
    }

    #[test]
    fn test_markdown_lite_to_html_hashtag() {
        let text = "#hashtag test";
        let html = markdown_lite_to_html(text).unwrap();
        assert_eq!(html, format!("<p>{}</p>", text));
    }

    #[test]
    fn test_markdown_lite_to_html_object_link() {
        let text = "[[https://example.org/objects/1]] test";
        let html = markdown_lite_to_html(text).unwrap();
        assert_eq!(html, format!("<p>{}</p>", text));
    }

    #[test]
    fn test_markdown_lite_to_html_double_quote() {
        let text = r#"quote "test #tag" end"#;
        let html = markdown_lite_to_html(text).unwrap();
        assert_eq!(html, "<p>quote &quot;test #tag&quot; end</p>");
    }

    #[test]
    fn test_markdown_lite_to_html_email_autolink() {
        let text = "test hello@gmail.com test";
        let html = markdown_lite_to_html(text).unwrap();
        assert_eq!(html, r#"<p>test hello@gmail.com test</p>"#);
    }

    #[test]
    fn test_markdown_lite_to_html_bitcoin_autolink() {
        // Bitcoin URI doesn't include ://
        let text = "test bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W.";
        let html = markdown_lite_to_html(text).unwrap();
        assert_eq!(html, r#"<p>test bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W.</p>"#);
    }

    #[test]
    fn test_markdown_lite_to_html_gemini_autolink() {
        let text = "test gemini://geminispace.info.";
        let html = markdown_lite_to_html(text).unwrap();
        assert_eq!(html, r#"<p>test <a href="gemini://geminispace.info">gemini://geminispace.info</a>.</p>"#);
    }

    #[test]
    fn test_markdown_lite_to_html_unknown_uri_autolink() {
        let text = "test x://a";
        let html = markdown_lite_to_html(text).unwrap();
        assert_eq!(html, r#"<p>test x://a</p>"#);
    }

    #[test]
    fn test_markdown_lite_to_html_ipv6_autolink() {
        let text = "test http://[319:3cf0:dd1d:47b9:20c:29ff:fe2c:39be]/test";
        let html = markdown_lite_to_html(text).unwrap();
        assert_eq!(html, r#"<p>test <a href="http://[319:3cf0:dd1d:47b9:20c:29ff:fe2c:39be]/test">http://[319:3cf0:dd1d:47b9:20c:29ff:fe2c:39be]/test</a></p>"#);
    }

    #[test]
    fn test_markdown_lite_to_html_ipv6_autolink_nex() {
        let text = "test nex://[319:3cf0:dd1d:47b9:20c:29ff:fe2c:39be]/test";
        let html = markdown_lite_to_html(text).unwrap();
        assert_eq!(html, r#"<p>test <a href="nex://[319:3cf0:dd1d:47b9:20c:29ff:fe2c:39be]/test">nex://[319:3cf0:dd1d:47b9:20c:29ff:fe2c:39be]/test</a></p>"#);
    }

    #[test]
    fn test_markdown_basic_to_html() {
        let text = "test **bold** test *italic* test ~~strike~~ with `code`, <span>html</span> and https://example.com and admin@email.example\nnew line\n\nanother line";
        let html = markdown_basic_to_html(text).unwrap();
        let expected_html = concat!(
            "<p>",
            "test **bold** test *italic* test ~~strike~~ with `code`, &lt;span&gt;html&lt;/span&gt;",
            r#" and <a href="https://example.com">https://example.com</a>"#,
            r#" and admin@email.example"#,
            "<br>new line<br></p>",
            "<p>another line</p>",
        );
        assert_eq!(html, expected_html);
    }

    #[test]
    fn test_markdown_basic_to_html_strikethrough() {
        let text = "test ~~strikethrough~~";
        let html = markdown_basic_to_html(text).unwrap();
        assert_eq!(html, format!("<p>{}</p>", text));
    }

    #[test]
    fn test_markdown_basic_to_html_mention() {
        let text = "@user@example.org test";
        let html = markdown_basic_to_html(text).unwrap();
        assert_eq!(html, format!("<p>{}</p>", text));
    }

    #[test]
    fn test_markdown_basic_to_html_unknown_uri_autolink() {
        let text = "test x://a";
        let html = markdown_basic_to_html(text).unwrap();
        assert_eq!(html, r#"<p>test x://a</p>"#);
    }

    #[test]
    fn test_markdown_basic_to_html_email_link() {
        // Regular link
        let text = "[my email](mailto:user@email.example)";
        let html = markdown_basic_to_html(text).unwrap();
        assert_eq!(html, r#"<p><a href="mailto:user@email.example">my email</a></p>"#);
        // Autolink
        let text = "user@email.example";
        let html = markdown_basic_to_html(text).unwrap();
        assert_eq!(html, "<p>user@email.example</p>");
    }

    #[test]
    fn test_markdown_to_html() {
        let text = "# heading\n\ntest";
        let html = markdown_to_html(text);
        assert_eq!(
            html,
            "<h1>heading</h1>\n<p>test</p>\n",
        );
    }
}
